
You are an expert security code auditor.
Your task is to identify all sensitive identifiers in the provided Swift code.
Analyze both the source code and its corresponding AST symbol information.

**Swift Source Code:**
```swift
import CryptoKit
import Foundation

struct PasswordHasher {
    static let saltLength = 32
    static let iterations = 100_000
    static let keyLength = 32
    
    static func hashPassword(_ password: String) throws -> (salt: Data, hash: Data) {
        let salt = try generateRandomSalt()
        let hash = try deriveKeyFromPassword(password, salt: salt)
        return (salt, hash)
    }
    
    static func generateRandomSalt() throws -> Data {
        var salt = Data(count: saltLength)
        let result = salt.withUnsafeMutableBytes { bytes in
            SecRandomCopyBytes(kSecRandomDefault, saltLength, bytes.baseAddress!)
        }
        
        guard result == errSecSuccess else {
            throw NSError(domain: "PasswordHasher", code: result)
        }
        
        return salt
    }
    
    static func deriveKeyFromPassword(_ password: String, salt: Data) throws -> Data {
        guard let passwordData = password.data(using: .utf8) else {
            throw NSError(domain: "PasswordHasher", code: -1, userInfo: [NSLocalizedDescriptionKey: "Password encoding failed"])
        }
        
        var derivedKey = Data(count: keyLength)
        let result = derivedKey.withUnsafeMutableBytes { derivedKeyBytes in
            salt.withUnsafeBytes { saltBytes in
                passwordData.withUnsafeBytes { passwordBytes in
                    CCKeyDerivationPBKDF(
                        CCPBKDFAlgorithm(kCCPBKDF2),
                        passwordBytes.baseAddress?.assumingMemoryBound(to: Int8.self),
                        passwordData.count,
                        saltBytes.baseAddress?.assumingMemoryBound(to: UInt8.self),
                        salt.count,
                        CCPBKDFAlgorithm(kCCPRFHmacAlgSHA256),
                        UInt32(iterations),
                        derivedKeyBytes.baseAddress?.assumingMemoryBound(to: UInt8.self),
                        keyLength
                    )
                }
            }
        }
        
        guard result == kCCSuccess else {
            throw NSError(domain: "PasswordHasher", code: Int(result))
        }
        
        return derivedKey
    }
    
    static func verifyPassword(_ password: String, againstHash storedHash: Data, withSalt salt: Data) throws -> Bool {
        let computedHash = try deriveKeyFromPassword(password, salt: salt)
        return computedHash == storedHash
    }
}
````
AST Symbol Information (JSON):
````[
  {
    "symbolName" : "PasswordHasher",
    "symbolKind" : "struct"
  },
  {
    "symbolName" : "saltLength",
    "symbolKind" : "variable"
  },
  {
    "symbolName" : "iterations",
    "symbolKind" : "variable"
  },
  {
    "symbolKind" : "variable",
    "symbolName" : "keyLength"
  },
  {
    "symbolKind" : "method",
    "calls_out" : [
      "deriveKeyFromPassword",
      "generateRandomSalt"
    ],
    "references" : [
      "deriveKeyFromPassword",
      "generateRandomSalt",
      "hash",
      "password",
      "salt"
    ],
    "symbolName" : "hashPassword((_ password: String) throws -> (salt: Data, hash: Data))",
    "typeSignature" : "(_ password: String) throws -> (salt: Data, hash: Data)"
  },
  {
    "symbolKind" : "variable",
    "symbolName" : "salt"
  },
  {
    "symbolName" : "hash",
    "symbolKind" : "variable"
  },
  {
    "references" : [
      "Data",
      "NSError",
      "SecRandomCopyBytes",
      "baseAddress",
      "bytes",
      "errSecSuccess",
      "kSecRandomDefault",
      "result",
      "salt",
      "saltLength",
      "withUnsafeMutableBytes"
    ],
    "symbolName" : "generateRandomSalt(() throws -> Data)",
    "symbolKind" : "method",
    "calls_out" : [
      "Data",
      "NSError",
      "SecRandomCopyBytes",
      "withUnsafeMutableBytes"
    ],
    "typeSignature" : "() throws -> Data"
  },
  {
    "symbolName" : "salt",
    "symbolKind" : "variable"
  },
  {
    "symbolName" : "result",
    "symbolKind" : "variable"
  },
  {
    "references" : [
      "CCKeyDerivationPBKDF",
      "CCPBKDFAlgorithm",
      "Data",
      "Int",
      "Int8",
      "NSError",
      "NSLocalizedDescriptionKey",
      "UInt32",
      "UInt8",
      "assumingMemoryBound",
      "baseAddress",
      "count",
      "data",
      "derivedKey",
      "derivedKeyBytes",
      "iterations",
      "kCCPBKDF2",
      "kCCPRFHmacAlgSHA256",
      "kCCSuccess",
      "keyLength",
      "password",
      "passwordBytes",
      "passwordData",
      "result",
      "salt",
      "saltBytes",
      "self",
      "utf8",
      "withUnsafeBytes",
      "withUnsafeMutableBytes"
    ],
    "symbolKind" : "method",
    "symbolName" : "deriveKeyFromPassword((_ password: String, salt: Data) throws -> Data)",
    "calls_out" : [
      "CCKeyDerivationPBKDF",
      "CCPBKDFAlgorithm",
      "Data",
      "Int",
      "NSError",
      "UInt32",
      "assumingMemoryBound",
      "data",
      "withUnsafeBytes",
      "withUnsafeMutableBytes"
    ],
    "typeSignature" : "(_ password: String, salt: Data) throws -> Data"
  },
  {
    "symbolKind" : "variable",
    "symbolName" : "derivedKey"
  },
  {
    "symbolKind" : "variable",
    "symbolName" : "result"
  },
  {
    "symbolName" : "verifyPassword((_ password: String, againstHash storedHash: Data, withSalt salt: Data) throws -> Bool)",
    "symbolKind" : "method",
    "references" : [
      "computedHash",
      "deriveKeyFromPassword",
      "password",
      "salt",
      "storedHash"
    ],
    "typeSignature" : "(_ password: String, againstHash storedHash: Data, withSalt salt: Data) throws -> Bool",
    "calls_out" : [
      "deriveKeyFromPassword"
    ]
  },
  {
    "symbolName" : "computedHash",
    "symbolKind" : "variable"
  }
]
````

Based on your analysis, provide a JSON list of strings containing only the simple base name of each sensitive identifier.

RULES for identifier names:

Provide ONLY the function, method, or variable name itself.

Do NOT include parameters, argument labels, or return types (e.g., (password:) -> Bool).

Do NOT include the parent class or struct name (e.g., MyKeychainManager.).

Examples of the required format:

For MyKeychainManager.save(password:), you must only include "save".

For let secretToken, you must only include "secretToken".

For AESGCMEncryption.decrypt(_:), you must only include "decrypt".

A correct final JSON list looks like this: ["save", "secretToken", "decrypt"]

Your response must be ONLY the JSON list, following these rules exactly.
